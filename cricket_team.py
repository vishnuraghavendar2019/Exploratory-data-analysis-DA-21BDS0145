# -*- coding: utf-8 -*-
"""cricket_pred.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t1-kooDDcvrMe3vX8XX6Cp90bUj08ou7
"""

import pandas as pd

# Load datasets
odi_bat = pd.read_csv('/content/ODI bat.csv', encoding='latin1')
t20_bat = pd.read_csv('/content/t20 bat.csv', encoding='latin1')
test_bat = pd.read_csv('/content/test bat.csv', encoding='latin1')
odi_bowl = pd.read_csv('/content/ODI Bowl.csv', encoding='latin1')
test_bowl = pd.read_csv('/content/test bowl.csv', encoding='latin1')
t20_bowl = pd.read_csv('/content/t20 bowl.csv', encoding='latin1')
pitch_data = pd.read_csv('/content/pitch type.csv', encoding='latin1')
soil_data = pd.read_csv('/content/soil type.csv', encoding='latin1')
stadium_data = pd.read_csv('/content/stadium.csv', encoding='latin1')


print("Datasets loaded successfully.")
print("\nODI Batting Data Preview:\n", odi_bat.head())
print("\nODI Bowling Data Preview:\n", odi_bowl.head())
print("\nTest Batting Data Preview:\n", test_bat.head())
print("\nTest Bowling Data Preview:\n", test_bowl.head())
print("\nT20 Batting Data Preview:\n", t20_bat.head())
print("\nT20 Bowling Data Preview:\n", t20_bowl.head())
print("\nPitch Data Preview:\n", pitch_data.head())
print("\nSoil Data Preview:\n", soil_data.head())
print("\nStadium Data Preview:\n", stadium_data.head())

# Check data types and initial structure
print(odi_bat.info())
print(odi_bowl.info())
print(test_bat.info())
print(test_bowl.info())
print(t20_bat.info())
print(t20_bowl.info())
print(pitch_data.info())
print(soil_data.info())
print(stadium_data.info())

# Step 3: Display missing values in each dataset
for name, df in zip(['ODI Batting', 'ODI Bowling', 'Test Batting', 'Test Bowling', 'T20 Batting', 'T20 Bowling', 'Pitch Data', 'Soil Data', 'Stadium Data'], [odi_bat, odi_bowl, test_bat, test_bowl, t20_bat, t20_bowl, pitch_data, soil_data, stadium_data]):
    missing = df.isnull().sum()
    print(f"{name} Missing Values:")
    print(missing[missing > 0])
    print("\n")

# Step 4: Remove rows with null values in Player, Country, Runs, or Strike rate
for name, df in zip(['ODI Batting', 'ODI Bowling', 'Test Batting', 'Test Bowling', 'T20 Batting', 'T20 Bowling'], [odi_bat, odi_bowl, test_bat, test_bowl, t20_bat, t20_bowl]):
    if all(col in df.columns for col in ['Player', 'Country', 'Runs', 'Strike rate']):
        df.dropna(subset=['Player', 'Country', 'Runs', 'Strike rate'], inplace=True)
        print(f"{name}: Rows with null values in Player, Country, Runs, or Strike rate removed.")

# Display data after removal
for name, df in zip(['ODI Batting', 'ODI Bowling', 'Test Batting', 'Test Bowling', 'T20 Batting', 'T20 Bowling'], [odi_bat, odi_bowl, test_bat, test_bowl, t20_bat, t20_bowl]):
    print(f"{name} After Null Removal:\n", df.head())

# Step 5: Convert numeric columns to proper data types
numeric_columns = ['Matches', 'Innings', 'Runs', 'Balls faced', 'Strike rate', 'Overs', 'Wkts', 'Economy', 'Average']
for df in [odi_bat, odi_bowl, test_bat, test_bowl, t20_bat, t20_bowl]:
    for col in numeric_columns:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce')

for name, df in zip(['ODI Batting', 'ODI Bowling', 'Test Batting', 'Test Bowling', 'T20 Batting', 'T20 Bowling'], [odi_bat, odi_bowl, test_bat, test_bowl, t20_bat, t20_bowl]):
    print(f"{name} Data Types After Conversion:\n", df.dtypes)

# Step 6: Remove duplicate rows from all datasets
for name, df in zip(['ODI Batting', 'ODI Bowling', 'Test Batting', 'Test Bowling', 'T20 Batting', 'T20 Bowling', 'Pitch Data', 'Soil Data', 'Stadium Data'], [odi_bat, odi_bowl, test_bat, test_bowl, t20_bat, t20_bowl, pitch_data, soil_data, stadium_data]):
    df.drop_duplicates(inplace=True)
    print(f"{name}: Duplicate rows removed. Current shape: {df.shape}")

# Step 8: Standardize text data in categorical columns
for name, df in zip(['ODI Batting', 'ODI Bowling', 'Test Batting', 'Test Bowling', 'T20 Batting', 'T20 Bowling', 'Pitch Data', 'Soil Data', 'Stadium Data'], [odi_bat, odi_bowl, test_bat, test_bowl, t20_bat, t20_bowl, pitch_data, soil_data, stadium_data]):
    for col in df.select_dtypes(include=[object]).columns:
        df[col] = df[col].str.strip().str.title()
    print(f"{name}: Categorical text data standardized.\n", df.head())

# Step 9: Save cleaned datasets to CSV
odi_bat.to_csv('cleaned_odi_bat.csv', index=False)
odi_bowl.to_csv('cleaned_odi_bowl.csv', index=False)
test_bat.to_csv('cleaned_test_bat.csv', index=False)
test_bowl.to_csv('cleaned_test_bowl.csv', index=False)
t20_bat.to_csv('cleaned_t20_bat.csv', index=False)
t20_bowl.to_csv('cleaned_t20_bowl.csv', index=False)
pitch_data.to_csv('cleaned_pitch_data.csv', index=False)
soil_data.to_csv('cleaned_soil_data.csv', index=False)
stadium_data.to_csv('cleaned_stadium_data.csv', index=False)

print("All cleaned datasets have been saved successfully.")

import pandas as pd

# Load cleaned datasets
odi_bat = pd.read_csv('cleaned_odi_bat.csv')
t20_bat = pd.read_csv('cleaned_t20_bat.csv')
test_bat = pd.read_csv('cleaned_test_bat.csv')
odi_bowl = pd.read_csv('cleaned_odi_bowl.csv')
t20_bowl = pd.read_csv('cleaned_t20_bowl.csv')
test_bowl = pd.read_csv('cleaned_test_bowl.csv')
pitch_data = pd.read_csv('cleaned_pitch_data.csv')
soil_data = pd.read_csv('cleaned_soil_data.csv')
stadium_data = pd.read_csv('cleaned_stadium_data.csv')

import numpy as np
# 1.1 Classify Batsmen (Defensive, Radical, Brute) based on format-specific strike rates

def classify_batsman(format_type, strike_rate):
    """
    Categorizes batsman as Defensive, Radical, or Brute based on strike rate & format.
    """
    if format_type == 'T20':
        if strike_rate <= 125:
            return 'Defensive'
        elif strike_rate <= 150:  # implicitly > 125
            return 'Radical'
        else:
            return 'Brute'
    elif format_type == 'ODI':
        if strike_rate <= 100:
            return 'Defensive'
        elif strike_rate <= 125:  # implicitly > 100
            return 'Radical'
        else:
            return 'Brute'
    elif format_type == 'TEST':
        if strike_rate < 50:
            return 'Defensive'
        elif strike_rate <= 100:  # implicitly >= 50
            return 'Radical'
        else:
            return 'Brute'
    return 'Unknown'  # fallback

# Apply the classification to each dataset
t20_bat['BatCategory'] = t20_bat['Strike rate'].apply(lambda x: classify_batsman('T20', x))
odi_bat['BatCategory'] = odi_bat['Strike rate'].apply(lambda x: classify_batsman('ODI', x))
test_bat['BatCategory'] = test_bat['Strike rate'].apply(lambda x: classify_batsman('TEST', x))

print("Batsmen classification completed for T20, ODI, and Test formats.")
print("\nT20 Batsmen after classification:\n", t20_bat[['Player', 'BatCategory']])
print("\nODI Batsmen after classification:\n", odi_bat[['Player', 'BatCategory']])
print("\nTest Batsmen after classification:\n", test_bat[['Player', 'BatCategory']])

# ------------------
# STEP 2: ASSIGN WEIGHTS
# ------------------

# Example weighting:
# We give numeric weights to each batting category depending on format
WEIGHTS_BAT = {
    'T20': {
        'Defensive': 0.8,
        'Radical': 1.0,
        'Brute': 1.2
    },
    'ODI': {
        'Defensive': 1.0,
        'Radical': 1.1,
        'Brute': 1.1
    },
    'TEST': {
        'Defensive': 1.2,
        'Radical': 1.0,
        'Brute': 0.9
    }
}


print("WEIGHTS_BAT:\n", WEIGHTS_BAT)

# For bowlers, consider economy or average important for T20, wicket-taking for Test, etc.
# We'll define a simple approach: pace vs. spin, etc.
# (Expand logic as needed)
WEIGHTS_BOWL = {
    'T20': {
        'Pace': 1.1,
        'Spin': 1.0
    },
    'ODI': {
        'Pace': 1.0,
        'Spin': 1.0
    },
    'TEST': {
        'Pace': 1.0,
        'Spin': 1.1
    }
}

# We'll use these weight dictionaries in Step 3 (Impact Score) to multiply relevant stats


print("Step 2 completed: Weights assigned to batting categories and bowling styles.")
print("\nWEIGHTS_BOWL:\n", WEIGHTS_BOWL)

# Calculaing impact score fot batsmen:

def calculate_batting_impact(row, format_type):
    strike_rate = row['Strike rate']
    classification = classify_batsman(format_type, strike_rate)
    weight = WEIGHTS_BAT[format_type.upper()][classification]

    # Example formula: (avg * 0.4 + runs/1000 * 0.3) * type weight
    avg_score = row['Average'] if not pd.isna(row['Average']) else 0
    total_runs = row['Runs'] if not pd.isna(row['Runs']) else 0

    base_score = (avg_score * 0.4) + (total_runs / 1000 * 0.3)
    impact_score = base_score * weight
    return pd.Series([classification, impact_score])

# Assuming t20_bat DataFrame is already loaded
t20_bat[['BatsmanType', 'ImpactScore']] = t20_bat.apply(lambda row: calculate_batting_impact(row,'T20'), axis=1)
odi_bat[['BatsmanType', 'ImpactScore']] = odi_bat.apply(lambda row: calculate_batting_impact(row, 'ODI'), axis=1)
test_bat[['BatsmanType', 'ImpactScore']] = test_bat.apply(lambda row: calculate_batting_impact(row, 'TEST'), axis=1)

print("\nT20 Bat after classification and BatImpact:\n", t20_bat[['Player','BatCategory','ImpactScore']])

def calculate_bowling_impact(row, format_type):
    btype = str(row['Bowling_Type']).lower()
    weight = WEIGHTS_BOWL.get(format_type.upper(), {}).get(btype, 1.0)

    # Clean inputs
    avg = row['Average'] if pd.notna(row['Average']) and row['Average'] > 0 else 50  # Assume worse if 0 or NaN
    econ = row['Economy'] if pd.notna(row['Economy']) and row['Economy'] > 0 else 10
    wkts = row['Wkts'] if pd.notna(row['Wkts']) else 0

    # Normalize inputs and calculate
    # More wickets = better, lower economy and average = better
    raw_score = weight * ((wkts * 1.0) + (50 / avg) + (10 / econ))

    # Clamp to non-negative
    impact_score = max(raw_score, 0)

    return pd.Series([btype.capitalize(), impact_score])

t20_bowl[['Bowling_Type', 'ImpactScore']] = t20_bowl.apply(lambda row: calculate_bowling_impact(row, 'T20'), axis=1)

odi_bowl[['Bowling_Type', 'ImpactScore']] = odi_bowl.apply(lambda row: calculate_bowling_impact(row, 'ODI'), axis=1)

test_bowl[['Bowling_Type', 'ImpactScore']] = test_bowl.apply(lambda row: calculate_bowling_impact(row, 'TEST'), axis=1)

# Show top impact bowlers
t20_bowl.sort_values('ImpactScore', ascending=False)[['Player', 'Bowling_Type', 'ImpactScore']].head(10)

def tag_roles_and_identify_allrounders(batting_df, bowling_df, format_type,
                                       batting_threshold=5, bowling_threshold=15):
    bat_df = batting_df.copy()
    bowl_df = bowling_df.copy()

    bat_df.rename(columns={'ImpactScore': 'ImpactScore_bat'}, inplace=True)
    bowl_df.rename(columns={'ImpactScore': 'ImpactScore_bowl'}, inplace=True)

    merged_df = pd.merge(
        bat_df, bowl_df,
        on=['Player', 'Country'],
        how='outer'
    )

    merged_df['ImpactScore_bat'] = merged_df['ImpactScore_bat'].fillna(0)
    merged_df['ImpactScore_bowl'] = merged_df['ImpactScore_bowl'].fillna(0)

    def tag_role(row):
        bat_ok = row['ImpactScore_bat'] >= batting_threshold
        bowl_ok = row['ImpactScore_bowl'] >= bowling_threshold
        if bat_ok and bowl_ok:
            return 'allrounder'
        elif bat_ok:
            return 'batsman'
        elif bowl_ok:
            return 'bowler'
        else:
            return 'unknown'

    merged_df['Role'] = merged_df.apply(tag_role, axis=1)
    merged_df = merged_df[merged_df['Role'] != 'unknown'].reset_index(drop=True)
    merged_df['Format'] = format_type.upper()

    allrounder_names = set(merged_df[merged_df['Role'] == 'allrounder']['Player'])

    return merged_df, allrounder_names

# For T20
t20_merged, t20_allrounders = tag_roles_and_identify_allrounders(t20_bat, t20_bowl, 'T20')

# For ODI
odi_merged, odi_allrounders = tag_roles_and_identify_allrounders(odi_bat, odi_bowl, 'ODI')

# For Test
test_merged, test_allrounders = tag_roles_and_identify_allrounders(test_bat, test_bowl, 'TEST')

# Run the function
t20_merged, t20_allrounders = tag_roles_and_identify_allrounders(t20_bat, t20_bowl, 'T20')

# Print merged dataframe
print("=== Merged Player Dataset (T20) ===")
print(test_merged[['Player', 'Country', 'Role', 'ImpactScore_bat', 'ImpactScore_bowl', 'Bowling_Type', 'Format']])

# Print allrounders
print("\n=== Identified All-Rounders ===")
print(t20_allrounders)

t20_merged.to_csv('t20_merged.csv', index=False)
test_merged.to_csv('test_merged.csv', index=False)
odi_merged.to_csv('odi_merged.csv', index=False)

"""TRYING ML

def get_balanced_playing_eleven_and_subs(merged_df, team_name, format_type,
                                         num_batsmen=5, num_bowlers=4, num_allrounders=2, num_subs=3,
                                         unavailable_players=None):
    if unavailable_players is None:
        unavailable_players = []

    merged_df['Country'] = merged_df['Country'].str.strip().str.upper()
    merged_df['Format'] = merged_df['Format'].str.strip().str.upper()
    team_name = team_name.strip().upper()
    format_type = format_type.strip().upper()

    df = merged_df[
        (merged_df['Country'] == team_name) &
        (merged_df['Format'] == format_type) &
        (~merged_df['Player'].isin(unavailable_players))
    ].copy()

    if df.empty:
        print(f"No players found for {team_name} in {format_type}")
        return pd.DataFrame(), pd.DataFrame()

    df['ImpactScore_bowl'] = df['ImpactScore_bowl'].apply(lambda x: max(0, x) if pd.notnull(x) else x)

    df['AllrounderScore'] = df.apply(
        lambda row: (row['ImpactScore_bat'] + row['ImpactScore_bowl']) / 2
        if row['Role'] == 'allrounder' else None, axis=1
    )

    batsmen = df[df['Role'] == 'batsman'].sort_values(by='ImpactScore_bat', ascending=False).head(num_batsmen)
    bowlers = df[df['Role'] == 'bowler'].sort_values(by='ImpactScore_bowl', ascending=False).head(num_bowlers)
    allrounders = df[df['Role'] == 'allrounder'].sort_values(by='AllrounderScore', ascending=False).head(num_allrounders)

    playing_xi = pd.concat([batsmen, allrounders, bowlers])
    selected_players = set(playing_xi['Player'])

    if len(playing_xi) < 11:
        needed = 11 - len(playing_xi)
        remaining = df[~df['Player'].isin(selected_players)].copy()
        remaining['BestScore'] = remaining.apply(
            lambda row: row['AllrounderScore'] if row['Role'] == 'allrounder'
            else row['ImpactScore_bat'] if row['Role'] == 'batsman'
            else row['ImpactScore_bowl'], axis=1
        )
        fillers = remaining.sort_values(by='BestScore', ascending=False).head(needed)
        playing_xi = pd.concat([playing_xi, fillers])
        selected_players.update(fillers['Player'])

    playing_xi['RoleRank'] = playing_xi['Role'].map({'batsman': 1, 'allrounder': 2, 'bowler': 3})
    playing_xi = playing_xi.sort_values(by=['RoleRank', 'ImpactScore_bat', 'ImpactScore_bowl'], ascending=[True, False, False])

    remaining = df[~df['Player'].isin(selected_players)].copy()
    remaining['BestScore'] = remaining.apply(
        lambda row: row['AllrounderScore'] if row['Role'] == 'allrounder'
        else row['ImpactScore_bat'] if row['Role'] == 'batsman'
        else row['ImpactScore_bowl'], axis=1
    )
    substitutes = remaining.sort_values(by='BestScore', ascending=False).head(num_subs)

    return playing_xi.drop(columns=['RoleRank']).reset_index(drop=True), substitutes.reset_index(drop=True)"

def get_balanced_playing_eleven_and_subs(merged_df, team_name, format_type,
                                         num_batsmen=5, num_bowlers=4, num_allrounders=2, num_subs=3,
                                         unavailable_players=None):
    if unavailable_players is None:
        unavailable_players = []

    # Normalize strings
    merged_df['Country'] = merged_df['Country'].str.strip().str.upper()
    merged_df['Format'] = merged_df['Format'].str.strip().str.upper()
    team_name = team_name.strip().upper()
    format_type = format_type.strip().upper()

    # Filter by team, format, and availability
    df = merged_df[
        (merged_df['Country'] == team_name) &
        (merged_df['Format'] == format_type) &
        (~merged_df['Player'].isin(unavailable_players))
    ].copy()

    if df.empty:
        print(f"No players found for {team_name} in {format_type}")
        return pd.DataFrame(), pd.DataFrame()

    # Clamp negative bowling impact scores to 0
    df['ImpactScore_bowl'] = df['ImpactScore_bowl'].apply(lambda x: max(0, x) if pd.notnull(x) else x)

    # Allrounder Score
    df['AllrounderScore'] = df.apply(
        lambda row: (row['ImpactScore_bat'] + row['ImpactScore_bowl']) / 2
        if row['Role'] == 'allrounder' else None, axis=1
    )

    # Select by role
    batsmen = df[df['Role'] == 'batsman'].sort_values(by='ImpactScore_bat', ascending=False).head(num_batsmen)
    bowlers = df[df['Role'] == 'bowler'].sort_values(by='ImpactScore_bowl', ascending=False).head(num_bowlers)
    allrounders = df[df['Role'] == 'allrounder'].sort_values(by='AllrounderScore', ascending=False).head(num_allrounders)

    # Combine and fill up to 11 if needed
    playing_xi = pd.concat([batsmen, allrounders, bowlers])
    selected_players = set(playing_xi['Player'])

    if len(playing_xi) < 11:
        needed = 11 - len(playing_xi)
        remaining = df[~df['Player'].isin(selected_players)].copy()
        remaining['BestScore'] = remaining.apply(
            lambda row: row['AllrounderScore'] if row['Role'] == 'allrounder'
            else row['ImpactScore_bat'] if row['Role'] == 'batsman'
            else row['ImpactScore_bowl'], axis=1
        )
        fillers = remaining.sort_values(by='BestScore', ascending=False).head(needed)
        playing_xi = pd.concat([playing_xi, fillers])
        selected_players.update(fillers['Player'])

    # Sort by role priority
    playing_xi['RoleRank'] = playing_xi['Role'].map({'batsman': 1, 'allrounder': 2, 'bowler': 3})
    playing_xi = playing_xi.sort_values(by=['RoleRank', 'ImpactScore_bat', 'ImpactScore_bowl'], ascending=[True, False, False])

    # Prepare substitutes
    remaining = df[~df['Player'].isin(selected_players)].copy()
    remaining['BestScore'] = remaining.apply(
        lambda row: row['AllrounderScore'] if row['Role'] == 'allrounder'
        else row['ImpactScore_bat'] if row['Role'] == 'batsman'
        else row['ImpactScore_bowl'], axis=1
    )
    substitutes = remaining.sort_values(by='BestScore', ascending=False).head(num_subs)

    return playing_xi.drop(columns=['RoleRank']).reset_index(drop=True), substitutes.reset_index(drop=True)
"""

# --------------------- Clean Toss Prediction Module ---------------------

# Install dependencies (if needed in fresh Colab)
# !pip install pandas scikit-learn matplotlib --quiet

import pandas as pd
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
import random
import matplotlib.pyplot as plt

# Sample training data
data = pd.DataFrame({
    'SoilType': ['Black Soil', 'Red Soil', 'Loam Soil', 'Sandy Soil'] * 5,
    'PitchType': ['Green Top', 'Dry/Dusty', 'Flat', 'Rank Turner', 'Hard Pitch'] * 4,
    'Stadium': ['Wankhede Stadium', "Lord's", 'MCG', 'Wanderers', 'Eden Park'] * 4,
    'DewPresence': ['Yes', 'No'] * 10,
    'BatOrBowl': [random.choice(['Bat', 'Bowl']) for _ in range(20)]
})

# Encode categorical features
label_encoders = {}
for column in ['SoilType', 'PitchType', 'Stadium', 'DewPresence']:
    le = LabelEncoder()
    data[column] = le.fit_transform(data[column])
    label_encoders[column] = le

# Encode target
bat_bowl_le = LabelEncoder()
data['BatOrBowl'] = bat_bowl_le.fit_transform(data['BatOrBowl'])

# Train the model
X = data[['SoilType', 'PitchType', 'Stadium', 'DewPresence']]
y = data['BatOrBowl']
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X, y)

# Score data by stadium and format
score_data = {
    'Wankhede Stadium': {'T20': (180, 170), 'ODI': (280, 260), 'Test': (350, 330)},
    "Lord's": {'T20': (160, 150), 'ODI': (240, 220), 'Test': (320, 310)},
    'MCG': {'T20': (170, 165), 'ODI': (260, 250), 'Test': (330, 310)},
    'Wanderers': {'T20': (180, 175), 'ODI': (270, 260), 'Test': (340, 320)},
    'Eden Park': {'T20': (170, 160), 'ODI': (250, 240), 'Test': (320, 300)}
}

# --------------------- Main Toss Prediction Function ---------------------
def run_toss_prediction(soil_type, pitch_type, stadium, dew, match_format):
    encoded_input = [
        label_encoders['SoilType'].transform([soil_type])[0],
        label_encoders['PitchType'].transform([pitch_type])[0],
        label_encoders['Stadium'].transform([stadium])[0],
        label_encoders['DewPresence'].transform([dew])[0],
    ]

    prediction_encoded = model.predict([encoded_input])[0]
    bat_or_bowl = bat_bowl_le.inverse_transform([prediction_encoded])[0]

    # Score lookup
    first_innings, second_innings = score_data[stadium][match_format]

    score_diff = abs(first_innings - second_innings)
    if dew == 'Yes':
        win_bat = 55 + (score_diff // 5) if bat_or_bowl == 'Bat' else 45 - (score_diff // 5)
    else:
        win_bat = 50 + (score_diff // 5) if bat_or_bowl == 'Bat' else 50 - (score_diff // 5)

    win_bat = max(10, min(90, win_bat))
    win_bowl = 100 - win_bat

    return {
        'Bat or Bowl': bat_or_bowl,
        'Estimated Score Bat First': first_innings,
        'Estimated Score Bowl First': second_innings,
        'Winning % for Batting First': win_bat,
        'Winning % for Bowling First': win_bowl
    }

# --------------------- Optional Visualization ---------------------
def plot_results(result):
    labels = ['Bat First', 'Bowl First']
    win_chances = [result['Winning % for Batting First'], result['Winning % for Bowling First']]

    plt.bar(labels, win_chances, color=['green', 'blue'])
    plt.title('Winning Probability')
    plt.xlabel('Strategy')
    plt.ylabel('Winning Percentage')
    plt.ylim(0, 100)
    plt.show()

result = run_toss_prediction(
    soil_type="Red Soil",
    pitch_type="Flat",
    stadium="MCG",
    dew="Yes",
    match_format="ODI"
)

print(result)
plot_results(result)

# -------------------------------
# ðŸ Complete Code: Team 11 & Substitutes Predictor
# -------------------------------

# 1. Imports
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, ExtraTreesClassifier, GradientBoostingClassifier
from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score, mean_squared_error
import joblib

# 2. Load & Merge Datasets
odi = pd.read_csv('/content/odi_merged.csv')
t20 = pd.read_csv('/content/t20_merged.csv')
test = pd.read_csv('/content/test_merged.csv')
merged_df = pd.concat([odi, t20, test], ignore_index=True)
merged_df.to_csv('merged_cricket.csv', index=False)

# 3. Normalize columns
merged_df['Country'] = merged_df['Country'].str.upper().str.strip()
merged_df['Format'] = merged_df['Format'].str.upper().str.strip()

# 4. Labeling Logic for Playing 11
def get_balanced_playing_eleven_and_subs(df, country, match_format,
                                         num_batsmen=5, num_bowlers=4, num_allrounders=2, num_subs=4):
    team = df[(df['Country'] == country) & (df['Format'] == match_format)].copy()
    if team.empty:
        return pd.DataFrame(), pd.DataFrame()
    team['Prob_Selected'] = team['ImpactScore_bat'] + team['ImpactScore_bowl']
    batsmen = team[team['Role'] == 'batsman'].nlargest(num_batsmen, 'Prob_Selected')
    allrounders = team[team['Role'] == 'allrounder'].nlargest(num_allrounders, 'Prob_Selected')
    bowlers = team[team['Role'] == 'bowler'].nlargest(num_bowlers, 'Prob_Selected')
    playing = pd.concat([batsmen, allrounders, bowlers])
    if len(playing) < 11:
        needed = 11 - len(playing)
        others = team[~team['Player'].isin(playing['Player'])]
        fillers = others.nlargest(needed, 'Prob_Selected')
        playing = pd.concat([playing, fillers])
    remaining = team[~team['Player'].isin(playing['Player'])]
    subs = remaining.nlargest(num_subs, 'Prob_Selected')
    return playing, subs

def label_players(df):
    sel, _ = get_balanced_playing_eleven_and_subs(df, df['Country'].iloc[0], df['Format'].iloc[0])
    df['Selected'] = df['Player'].isin(sel['Player']).astype(int)
    return df

merged_df = merged_df.groupby(['Country', 'Format'], group_keys=False).apply(label_players)

# 5. Feature Engineering
features = ['ImpactScore_bat', 'ImpactScore_bowl']
categorical = ['Format']
X = merged_df[features + categorical]
y = merged_df['Selected']

# 6. Preprocessing
preprocessor = ColumnTransformer([
    ('num', StandardScaler(), features),
    ('cat', OneHotEncoder(handle_unknown='ignore'), categorical)
])

# 7. Train/Test Split
X_train, X_test, y_train, y_test = train_test_split(X, y, stratify=y, test_size=0.2, random_state=42)

# 8. Model Training & Evaluation
models = {
    'LogisticRegression': LogisticRegression(max_iter=1000),
    'RandomForest': RandomForestClassifier(n_estimators=200),
    'ExtraTrees': ExtraTreesClassifier(n_estimators=200),
    'GradientBoosting': GradientBoostingClassifier(),
    'XGBoost': XGBClassifier(eval_metric='mlogloss')
}

scores, mse_vals, pipelines = {}, {}, {}

for name, clf in models.items():
    pipe = Pipeline([
        ('preprocessor', preprocessor),
        ('classifier', clf)
    ])
    pipe.fit(X_train, y_train)
    scores[name] = accuracy_score(y_test, pipe.predict(X_test))
    mse_vals[name] = mean_squared_error(y_test, pipe.predict(X_test))
    pipelines[name] = pipe

# 9. Plot Accuracy and MSE
plt.figure(figsize=(12,5))
plt.subplot(1,2,1)
plt.bar(scores.keys(), scores.values())
plt.title('Model Accuracy')
plt.xticks(rotation=45)

plt.subplot(1,2,2)
plt.bar(mse_vals.keys(), mse_vals.values())
plt.title('Model MSE')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# 10. Save the Best Model
best_name = max(scores, key=scores.get)
best_pipeline = pipelines[best_name]
joblib.dump(best_pipeline, 'best_model_pipeline.pkl')
print(f"âœ… Best model: {best_name} saved as 'best_model_pipeline.pkl'")

# ðŸ” API-Ready Playing XI Predictor
def predict_playing_xi_api(model_pipeline, merged_df,
                            teamA, teamB, fmt,
                            ua=None, ub=None, sa=None, sb=None):

    ua = ua or []
    ub = ub or []
    sa = sa or []
    sb = sb or []

    fmt = fmt.strip().upper()
    teamA = teamA.strip().upper()
    teamB = teamB.strip().upper()

    features = ['ImpactScore_bat', 'ImpactScore_bowl']
    categorical = ['Format']

    def select_team(country, unavailable, star):
        df = merged_df[(merged_df['Country'] == country) & (merged_df['Format'] == fmt)].copy()
        df = df[~df['Player'].isin(unavailable)]

        if df.empty:
            return pd.DataFrame(), pd.DataFrame()

        X_team = df[features + categorical]
        probs = model_pipeline.predict_proba(X_team)[:, 1]
        df['Prob_Selected'] = probs

        # Select star players first
        stars_df = df[df['Player'].isin(star)]
        df = df[~df['Player'].isin(stars_df['Player'])]

        bats = df[df['Role'] == 'batsman'].nlargest(5, 'Prob_Selected')
        allr = df[df['Role'] == 'allrounder'].nlargest(2, 'Prob_Selected')
        bowl = df[df['Role'] == 'bowler'].nlargest(4, 'Prob_Selected')

        team = pd.concat([stars_df, bats, allr, bowl]).drop_duplicates(subset='Player')

        if len(team) < 11:
            needed = 11 - len(team)
            others = df[~df['Player'].isin(team['Player'])]
            team = pd.concat([team, others.nlargest(needed, 'Prob_Selected')])

        subs = df[~df['Player'].isin(team['Player'])].nlargest(4, 'Prob_Selected')
        return team.head(11), subs

    teamA_xi, teamA_subs = select_team(teamA, ua, sa)
    teamB_xi, teamB_subs = select_team(teamB, ub, sb)

    return {
        "teamA": {
            "XI": teamA_xi[['Player', 'Role', 'Prob_Selected']].to_dict(orient="records"),
            "Substitutes": teamA_subs[['Player', 'Role', 'Prob_Selected']].to_dict(orient="records")
        },
        "teamB": {
            "XI": teamB_xi[['Player', 'Role', 'Prob_Selected']].to_dict(orient="records"),
            "Substitutes": teamB_subs[['Player', 'Role', 'Prob_Selected']].to_dict(orient="records")
        }
    }

best_model = joblib.load("best_model_pipeline.pkl")

result = predict_playing_xi_api(
    model_pipeline=best_model,
    merged_df=merged_df,
    teamA="IND",
    teamB="AUS",
    fmt="ODI",
    ua=["Shami"],
    ub=["Hazlewood"],
    sa=["Rohit Sharma"],
    sb=["Steve Smith"]
)

from pprint import pprint
pprint(result)